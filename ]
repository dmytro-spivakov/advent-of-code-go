package day05

import (
	"fmt"
	"testing"
)

func TestSolution1(t *testing.T) {
	cases := map[string]int{
		"test_input11": 3,
	}

	for inputFile, expectedResult := range cases {
		result := Solution1(inputFile)
		if result != expectedResult {
			t.Fatalf("Solution1() = %d, expecting %d\n", result, expectedResult)
		} else {
			fmt.Printf("Solution1() = %d, OK\n", result)
		}
	}
}

// func TestSolution2(t *testing.T) {
// 	cases := map[string]int{
// 		"test_input21": 46,
// 	}
//
// 	for inputFile, expectedResult := range cases {
// 		result := Solution2(inputFile)
// 		if result != expectedResult {
// 			t.Fatalf("Solution2() = %d, expecting %d\n", result, expectedResult)
// 		} else {
// 			fmt.Printf("Solution2() = %d, OK\n", result)
// 		}
// 	}
// }

func TestInputRangeApplyMapping(t *testing.T) {
	inputRange := InputRange{start: 10, length: 10}

	mappingRange := MappingRange{srcStart: 15, destStart: 100, length: 10}
	mapped, unmapped, ok := inputRange.applyMapping(mappingRange)

	expectedMapped := InputRange{start: 100, length: 5}
	expectedUnmapped := InputRange{start: 10, length: 5}
	if ok && len(mapped) == 1 && len(unmapped) == 1 && mapped[0] == expectedMapped && unmapped[0] == expectedUnmapped {
		fmt.Printf("InputRange.applyMapping() = mapped: %v, unmapped: %v; OK\n", mapped[0].describe(), unmapped[0].describe())
	} else {
		t.Fatalf("InputRange.applyMapping() = mapped: %v, unmapped: %v; FAIL\n", mapped, unmapped)
	}

	cases := map[string][][][]int{
		"left outer unmapped": [][][]int{
			[][]int{{15, 100, 10}}, // MappingRange srcStart, destStart, length
			[][]int{{100, 5}},      // mapped InputRanges start, length
			[][]int{{10, 5}},       // unmapped InputRanges start, length
		},
		"right outer unmapped": [][][]int{
			[][]int{{5, 100, 10}},
			[][]int{{100, 5}},
			[][]int{{16, 5}},
		},
	}
	// cases:
	// left outer, overlap > 1
	// left outer, overlap = 1
	// right outer, overlap > 1
	// right outer, overlap = 1
	// middle: left + right outer and mapped
	// mapping range contains the whole input
}

func TestMappingRangeFindDest(t *testing.T) {
	rangeStr := MappingRange{srcStart: 10, destStart: 20, length: 10}
	cases := map[int]int{
		10: 20,
		20: 30,
		15: 25,
		9:  -1,
		31: -1,
	}

	for srcStart, expectedDest := range cases {
		result := rangeStr.findDest(srcStart)
		if result != expectedDest {
			t.Fatalf("Range.findDest() = %d, expecting %d\n", result, expectedDest)
		} else {
			fmt.Printf("Range.findDest() = %d, OK\n", result)
		}
	}
}
